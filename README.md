# Дневник погружения в работу с одноплатниками
Данная страничка создана в целях отражения моего собственного изучения работы с одноплатниками и ALTLinux на этих одноплатниках. В перспективе последующим применением оставленных здесь записей может стать формирование методических материалов для студентов, приходящих в лабораторию.



Я буду очень благодарен любым комментариям, замечаниям и дополнениям к моим заметкам, которые будут здесь публиковаться. Принимаю любые косяки и недочеты, как по содержанию, так и по форме :)

Мои контакты для связи — почта (taranev@basealt.ru) и телеграмм (@Yayatoureeeeee).

## Введение

Стоит сказать, что я до последнего момента мало сталкивался с разработкой, заточенной под архитектуру, отличающуюся от x86_64. Поэтому многое может быть для случайного читателя максимально очевидным, что для меня очевидным не являлось.

Стоит ввести некоторые вводные. 

Имеется: 

* лаборатория с отдельной локальной сетью по ethernet и wi-fi;
* десять стационарных компьютеров, на которых установлены ALT Рабочие Станции 11;
* 13 одноплатников Sipeed Lichee RV
* 12 одноплатников Mango PI
* Много мишуры для того, чтобы работать с одноплатниками: видеокабели, удлинители USB, UART переходники, карты памяти
* желание освоить написание кода под одноплатники и поделиться собственным опытом<br />
Конечным артефактом моего импровизированного дневника в моем представлении должен стать некоторый перечень лабораторных работ, который может помочь случайному читателю комфортно погрузиться в темы, которые заинтересуют меня.

## Старт работы с одноплатниками

В распоряжении лаборатории есть 2 типа одноплатников на основе микропроцессора Allwinner D1 [Sipeed](https://www.sipeed.com/) [Lichee RV](https://wiki.sipeed.com/hardware/en/lichee/RV/RV.html) и [MangoPi](https://mangopi.org) [MQ Pro](https://mangopi.org/mangopi_mqpro).

Первый вопрос, который возникает "Как их запустить?".  Довольно очевидно, что нужен носитель с операционной системой(в нашем случае карта памяти) и образ операционной системы.

### Установка образа операционной системы на носитель 
![Картридер](/pictures/картридер.jpg)

С образом операционной системы все довольно просто. 

Как я понял, обычно производитель платы предоставляет тестовый образ для демонстрации ее возможностей. В моем же случае из-за моего желания запустить на платах ALT возникла проблема отсутствия такого образа. С этим мне помог Иван Мельников, который собрал [такой образ](https://ftp.altlinux.org/pub/people/iv/images/riscv64/regular-sunxi-riscv64/) для Lichee RV.

Но как записать образ на карточку? На самом деле все довольно просто:

Распакуем архив с образом

```
$ xz -dk /путь/к/архиву
```

Затем, аккуратно вставляем флешку в **картридер**.

Узнаем с помощью lsblk название устройства, и если на нем уже есть точки монтирования, размонтируем.

```
$ lsblk
# umount /dev/sdX* # если что то было примонтировано
```

С помощью утилиты dd запишем образ на флешку:

```
# dd if=путь/к/образу.img of=/dev/sdX bs=4M status=progress
```

После указанных манипуляций мы должны получить карту памяти с готовой операционной системой.

### Включение и начало работы с платой 

Поскольку нам необходимо работать с платой, а платы у нас достаточно малоресурсные, чтобы работать на графике(хотя с данным образом Lichee RV ее поддерживает) нам нужно работать через консоль. Для работы с консолью пригодиться **UART-преобразователь**, подключаемый на три контакта  GPIO платы. Контакты TX и RX у Lichee RV подписаны на задней стороне платы, а "гребенка" Mango соответствует спецификации "гребенок" Raspberry PI.

![Джампер](/pictures/джампер%20на%20перехооднике.jpg)

Важно правильно выбрать на UART-преобразователе джампером напряжение. В нашем случае, для обоих одноплатников это 3.3V. 

Если выбрать напряжение ниже необходимого — передача данных просто не будет возможной, а вот если выбрать выше, то появится хорошая возможность спалить устройство. **ГОВОРЮ НА СОБСТВЕННОМ ОПЫТЕ, ВНИМАТЕЛЬНЕЕ!**

Подключаем UART-преобразователь к компьютеру. Для удобства может пригодиться usb-удлинитель, если ПК стационарный. Далее, соединяем пин GND на GPIO контактах с пином GND на преобразователе, а RX пины соединяем с TX пинами, и наоборот.

Теперь понадобится программа для взаимодействия с платой. Например можно воспользоваться tio:

```
# apt-get install tio
```

![UART-преобразователь](/pictures/соелинение%20переходника%20с%20GPIO%20ПЛАТЫ.jpg)

Подключимся к UART-преобразователю, и ждем поступления сигналов

```
$ tio -b 115200 /dev/ttyUSBX
```

Теперь если вставить флеш-карточку с записанной на нее образом в соответствующий интерфейс на плате, можно увидеть в консоли логи запуска операционной системы, а затем и приглашение ко вводу.

На всех регулярных сборках ALT регулярных сборках, до прохождения мастера первоначальной настройки, логинка *root* с паролем *altlinux*.

## Написание кода под RISCV-архитектуру
Я оказался в точке, в которой

* есть плата с архитектурой RISCV, под которую нужно писать программный код;
* есть ПК на архитектуре x86_64, на котором удобно писать программный код;
* есть сделать максимально комфортным процесс разработки и отладки кода;

Такие обстоятельства вынудили меня выяснить, что я могу сделать, чтобы облегчить себе жизнь.

Дальше возник вопрос, а собственно, как организуют работу с кодом люди, которые постоянно разрабатывают программный код, поставляемый на разные процессорные архитектуры. Я снова обратился к интернету и опыту коллег. Выяснилось, что делать это можно по-разному. Принцип, разумеется везде один:

* пишется код
* компилируется кросс-компилятором
* так или иначе переносится на целевую платформу ИЛИ целевая платформа эмулируется
* код запускается и отлаживается

### Кросс-компилятор

Первое, что оказалось необходимым — **кросс-компилятор**. Кросс-компилятор — это специальный компилятор, который позволяет компилировать код для платформы, отличной от той, на которой он выполняется.

Нужен кросс-компилятор? [Их есть у Альта!](https://packages.altlinux.org/en/sisyphus/srpms/cross-toolchain-riscv64-linux-gnu/) 

Ставим:

```
# apt-get install gcc-riscv64-linux-gnu
```

Прекрасно. Кросс-компилятор — есть.

### IDE или не IDE

Нужно решить, где писать программный код. Мой собственный, не самый долгий опыт разработки всегда был связан с разработкой кода с помощью IDE, не все мои коллеги разделяют такой подход. Кому то привычно быть независимым от возможностей графического отображения всего подряд и обходиться без среды разработки. Для такого подхода имеются [основания](https://habr.com/ru/articles/303554/), и, быть может, я к этому тоже приду через время. Но в данный момент мне самому, и, думаю, многим читающим мои записи привычно использовать IDE, поэтому я решил не отказывать своей привычке. 

Я решил вести разработку в привычной мне среде Eclipse. С установкой никаких проблем: [установочник доступен на официальном сайте](https://www.eclipse.org/downloads/packages/installer). В профиле установочника выбираем *Eсlipse IDE for Embedded C/C++ Developers*.

### Сборка программы

Поскольку я выбрал быть счас...разработчиком, который пишет код в IDE это влечет за собой необходимость эту IDE настроить. Вернее, настраивать будем не IDE, а параметры, которые будут переданы *Make*.

Make — это утилита для автоматизации сборки программного обеспечения. Она читает инструкции из файла Makefile и выполняет компиляцию, линковку и другие задачи в зависимости от изменений в исходном коде.

Первое с чем предстоит столкнуться - это заставить *make* использовать для наших манипуляции с кодом **тулчейн**, который мы установили вместе с пакетом *gcc-riscv64-linux-gnu*.

**Тулчейн (Toolchain)** — это набор инструментов (утилит, компиляторов, библиотек), которые используются для разработки и сборки программного обеспечения под определенную платформу или архитектуру.

Cоздаем пустой проект C/C++ > C Managed Build > Hello World RISC-V C++ Project > RISC-V Cross GCC > Toolchain name = что_бы_то_ни_было & toolchain path = /usr/bin.

Можно попробовать собрать проект, и разумеется, ничего не выйдет поскольку *make* понятия не имеет, что такое *что_бы_то_ни_было*, которое мы выбрали в качестве имени тулчейна. Идем в Properties проекта > C/C++ Build > Settings > Toolchains. Вот здесь мы и настроим наш уже установленный в папку */usr/bin* тулчейн. Имя тулчейна можно оставить любое, архитектура RISCV, префикс устанавливаем *riscv64-linux-gnu-*, компиляторы gcc и g++. Затем проверяем, что toolchain path *usr/bin*, и применяем настройки. Теперь Make будет знать, где лежат и как называются все компоненты установленного тулчейна. Пробуем построить проект. Все должно получиться.

### Тестирование запуска бинарника на плате

Итак, теперь, наше *Hello World* приложение собрано для интересующей нас архитектуры. Можно попробовать ее исполнить, к чему и приступим.

Для этого авторизуемся в root на плате и настроим сеть

```
# nmcli dev show # узнаем как называется wifi-интерфейс
# nmcli dev wifi # узнаем доступные wifi сети
# nmcli dev wifi connect "название_сети" password "пароль_сети"

# ping ya.ru # проверим, что у появился DNS и выход в интернет

# ip a # узнаем текущий айпишник платы

```
Если плата находиться в одной сети с ПК, значит, можно попробовать подклюиться по ssh. Если до этого момента у вас есть только учетная запись root, необходимов в /etc/openssh/sshd_config расскомментировать параметр PermitRootLogin и поставить после его обяъявления значение "yes".

```
# apt-get install nano  # поставим редактор(если его не было)
# nano /etc/openssh/sshd_config # исправляем параметр(если надо)
# systemctl restart sshd # перезапустим, sshd
# systemctl status sshd # проверим, работает ли ssh
```

Если все хорошо, то можно передать скомпилированный бинарник на целевое устройство и там его выполнить

```
# scp /путь/до/бинарника имя_пользователя@айпи.нашей.riscv.платы:/куда/положить # пользователь по умолчанию root, пароль altlinux
```

Остается выполнить бинарник и порадоваться.

### Сборка в изолированный среде

Прекрасно! Но у меня сразу созрел вопрос. А как мне вести разработку дальше? Ведь, если писать не *Hello World* приложение, а что то чуть более серьезное, то появиться необходимость постоянно собирать программу вместе с различными заголовочными файлами, которые не входят в стандартную библиотеку. Кроме того, чтобы проверить работу приложения каждый раз нужно будет руками или каким то скриптом пересылать бинарник на плату и там его выполнять. Мне захотелось найти путь, по которому от этих неудобств можно избавиться.

Я спросил совета у опытного человека, который дал мне ценную идею и способ ее реализации. И, скажу откровенно, меня вся эта схема впечатлила. Не догадывался, что такое возможно. Данный способ обусловлен использованием связки двух технологий: [hasher](https://www.altlinux.org/Hasher) и [QEMU](https://ru.wikipedia.org/wiki/QEMU).

Стоит внести краткий вводные. 
*QEMU* – это эмулятор, который может выполнять код, предназначенный для одной архитектуры процессора, на другой. *qemu-user-static* – версия *QEMU*, работающая без полной эмуляции всей системы, обеспечивающая только исполнение бинарников.

*hasher* — это инструмент безопасной и воспроизводимой сборки пакетов. Инструмент спроектирован так, чтобы не допускать влияния собираемого пакета на хост-систему, а также взаимного влияния собирающихся пакетов.

В этой схеме qemu-user-static будет применяться по прямому назначению для запуска собранных бинарников, а hasher будет обеспечивать  изолированную среду, в которой будут тестироваться собранные пакеты, симулируя тем самым файловую систему реальной железки. Такая схема позволить запускать собираемые бинарники без их пересылки на реальное устройство и не беспокоится о коллизиях, которые могут возникнуть в рантайме приложения.

Если описать кратко перечень необходимых действий, то требуется следующая последовательность:

* Установить пакет qemu-user-static-binfmt-riscv
* Установить hasher и настроить его
* Поставить в hasher то, что нужно для сборки программы
* Передать chroot hasher мейку в качестве sysroot для кросс-компилятора
* Проверить результат работы в хэшере

Начнем с самого простого :)

```
# apt-get install qemu-user-static-binfmt-riscv
```

Теперь установим и настроим hasher.Предлагаю обратиться к [руководству по hasher](https://www.altlinux.org/Hasher/Руководство). По данному руководству необходимо выполнить некоторые конкретные пункты:

* Установка
* Добавление пользователя

После этого

```
$ mkdir ~/hasher # создаем директорию для сборочной среды(можно выбрать любое место, но на tmpfs будет быстрее см.руководство)
```

Далее создаю в папке ~/apt(или любой другой) файлы apt.conf.riscv64-pve и sources.list.riscv-pve. Данная конфигурация укажет хэшеру, откуда брать пакеты для установку в среду. Приведу содержимое файлов.

apt.conf.riscv64-pve
```
Dir::Etc::main "/dev/null";
Dir::Etc::parts "/var/empty";
Dir::Etc::SourceParts "/var/empty";
Dir::Etc::sourcelist "/ваш/хомяк/apt/sources.list.riscv-pve";

RPM::Ignore { "vim-plugin-vimruby"; };
```

sources.list.riscv-pve

```
rpm [sisyphus-riscv64] http://ftp.altlinux.org/pub/distributions/ALTLinux/ports/riscv64 >

rpm [sisyphus-riscv64] http://ftp.altlinux.org/pub/distributions/ALTLinux/ports/riscv64 >
```

После чего создаем окружение явно с указанием архитектуры, пути к конфигу для пакетного менеджера

```
$ hsh --init --target riscv64 --apt-conf ~/hasher/apt/riscv64-pve.conf ~/папка/с/вашим/окружением/hsh-rv64
```

Далее, если нам необходим или будет необходим какой то пакет внутри хэшера можно воспользоваться следующей командой, чтобы поставить в hasher нужное:

```
$ hsh-install ~/папка/с/вашим/окружением/hsh-rv64 название-необходимого-пакета
```

Кроме того, теперь у нас появилась возможность войти в окружение хэшер, и например выполнить в нем какой то скрипт или бинарник.

```
$ hsh-shell ~/папка/с/вашим/окружением/hsh-rv64
```

Фуууух. Дело осталось за малым. Нужно научить мейк передавать chroot в качестве sysroot кросс-компилятору и указывать компилятору откуда брать библиотеки. 

Решаем вопрос с библиотеками:

Перейдем в Настройки проекта > C/C++ Build > Settings > Tool Settings > GNU RISC-V CROSS C Compiler > Includes

```
Include paths = /путь/до/чрута/хэшера/usr/include
```

Перейдем в Настройки проекта > C/C++ Build > Settings > Tool Settings > GNU RISC-V CROSS C Linker > Libraries

```
Library search path = /путь/до/чрута/хэшера/usr/lib
```

Укажем chroot хэшера в качестве sysroot: 

Перейдем в Настройки проекта > C/C++ Build > Settings > Tool Settings > GNU RISC-V CROSS C Compiler > Command

```
Command=${cross_prefix}${cross_c} --sysroot ~/hasher/hsh-rv64/chroot ${cross_suffix}
```

### Исполнение программы в изолированной среде 

Для того, чтобы что-то выполнить в hasher, это что-то нужно туда поместить. Я решил поступить в лоб, и после компиляции бинарника копировать его в корень chroot хэшера, указав это в параметре make, в настройка сборки.

```
Post-build steps Command=cp ~/eclipse-workspace/путь/к/созданному/бинарнику.elf ~/путь/к/chroot
```
Пора настроить запуск нашего бинарника: в Run Configuration проекта указываем в параметре C/C++ Application 

```
/абсолютный/путь/в/chroot/бинарник.elf
```
 
На кураже совсем забыл указать, а зачем во всей это схеме нужен был пакет qemu-user-static-binfmt-riscv. Спасибо sorochaniv@basealt.ru за внимание к этому подразделу. Данный пакет позволяет запускать бинарники, скомпилированные под другую архитектуру. 

Только чтобы все заработало обязательно нужно во вкладке Environment указать значение переменной окружения. Спасибо за подсказку от *опытного коллеги*.

```
QEMU_LD_PREFIX=/абсолютный/путь/к/chroot
```

Данная переменная укажет,где находится динамический загрузчик (в нашем случае '/lib64/ld-linux-riscv64-lp64d.so.1'), который загружает и связывает динамические библиотеки при запуске программы.

Если все манипуляции были выполнены программу можно будет выполнить в hasher с помощью hsh-run, или зайдя в его окружение с помощью hsh-shell, или прямо из IDE, как на картинке.
![Запуск в IDE](/pictures/Запуск%20в%20IDE.png)



Теперь я почти счастлив. Была бы еще отладка...но с этим все несколько сложнее и надо разбираться :)

### Отладка в изолированный среде


......

# Потенциально полезные заметки 

Здесь размещается материал, который я не могу отнести к чему то конкретному, но опыт которого может быть применен мной или кем-то другим в будущем.


[Работа с логическим анализатором](https://github.com/Besogon1238/SSU-BaseALT/blob/main/Subpages/Logic%20Analyser.md)

